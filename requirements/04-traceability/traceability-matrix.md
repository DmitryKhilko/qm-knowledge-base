## Таблица трассировки требований/методов программного кода 

ИИ-агент автоматически обновляет таблицу при каждом пул-реквесте в основную ветку, а также по запросу пользователя. 

| Спецификация | Требование | Зависимости требования | Модуль | Метод | Зависимости метода |
|--------------|------------|------------------------|--------|-------|---------------------|
| SPEC-FEATURE-DELIVERY-NOTE-V-1.00 | FR-DELIVERY-NOTE-CREATE-001 | NFR-DELIVERY-NOTE-CREATE-001 | delivery_note.py | gln_epass() | - |
| SPEC-FEATURE-DELIVERY-NOTE-V-1.00 | FR-DELIVERY-NOTE-CREATE-002 | - | delivery_note.py | shipper_gln() | gln_epass() |
| SPEC-FEATURE-DELIVERY-NOTE-V-1.00 | FR-DELIVERY-NOTE-CREATE-003 | NFR-DELIVERY-NOTE-CREATE-002 | delivery_note.py | delivery_note_create() | shipper_gln() → gln_epass() |
| SPEC-FEATURE-DELIVERY-NOTE-DRAFT-V-1.00 | FR-DELIVERY-NOTE-DRAFT-CREATE-001 | FR-DELIVERY-NOTE-DRAFT-CREATE-002, NFR-DELIVERY-NOTE-DRAFT-CREATE-001 | delivery_note_draft.py | delivery_note_draft_create() | delivery_note.delivery_note_create() → delivery_note.shipper_gln() → delivery_note.gln_epass() |

## На какие вопросы отвечает таблица трассировки

**Вопрос:**  
Какие методы могут подвергнутся переработке при изменении требования FR-DELIVERY-NOTE-CREATE-002? Методы выведи в формате модуль.имя_метода(), через двоеточие опиши взаимосвязи методов. Дай итоговый ответ, рассуждения скрой.  
**Ответ:**  
При изменении требования FR-DELIVERY-NOTE-CREATE-002 могут подвергнуться переработке следующие методы:
1. delivery_note.shipper_gln() — прямое требование
2. delivery_note.delivery_note_create() → вызывает shipper_gln()
3. delivery_note_draft.delivery_note_draft_create() → вызывает delivery_note.delivery_note_create() → вызывает shipper_gln()

**Вопрос:**  
Я хочу произвести рефакторинг метода shipper_gln, какие требования это может затронуть? Сделай вывод в формате: "Требование" : "взаимосвязь с изменяемым методом". Методы выведи в формате модуль.имя_метода(). Дай итоговый ответ, рассуждения скрой.  
**Ответ:**  
Требования, которые могут быть затронуты при рефакторинге shipper_gln():
1. FR-DELIVERY-NOTE-CREATE-002 : прямое соответствие методу delivery_note.shipper_gln().
2. FR-DELIVERY-NOTE-CREATE-003 : косвенная зависимость через вызов delivery_note.delivery_note_create() → delivery_note.shipper_gln().
3. FR-DELIVERY-NOTE-DRAFT-CREATE-001 : косвенная зависимость через вызов delivery_note_draft.delivery_note_draft_create() → delivery_note.delivery_note_create() → delivery_note.shipper_gln().



## Правила для ИИ-агента для обновления таблицы

```
Создай таблицу трассируемости требований и методов программного кода.

Типы файлов для анализа:
1. Python-файлы с docstring, содержащими информацию о требованиях и спецификациях
2. Python-файлы с реализацией методов (для анализа вызовов других методов)
3. Markdown-файлы спецификаций с описанием требований и их зависимостей

Задача:
1. Проанализируй docstring py-файлов и извлеки связи:
1.1. Модуль (файл)
1.2. Метод (функция)
1.3. Спецификация (указана в docstring)
1.4. Требование (указано в docstring)

2. Проанализируй код методов в py-файлах и определи:
2.1. Все методы, которые вызываются внутри анализируемого метода (первого уровня)
2.2. Для каждого вызываемого метода (первого уровня) проанализируй его код и определи:
2.2.1. Методы, которые вызываются внутри него (второй уровень)
2.2.2.  Продолжай анализ вглубь по цепочке вызовов, пока не достигнешь методов без вызовов других методов
2.3. Учитывай прямые вызовы функций и методов
2.4. Если вызываемый метод находится в другом модуле, указывай его с префиксом модуля

3. Проанализируй md-файлы спецификаций и найди:
3.1. Указанные в docstring требования
3.2. Требования, от которых они зависят (ссылки, упоминания в тексте), независимо от их типа

4. Построй сводную таблицу в формате markdown с колонками:
|Спецификация|Требование|Зависимости требования|Модуль|Метод|Зависимости метода|

Правила заполнения таблицы:
1. Колонка "Требование":
    - Впиши ОСНОВНОЕ требование, указанное в docstring py-файла
    - Если в docstring указано несколько требований, включи их все через запятую
2. Колонка "Зависимости требования":
    - Впиши все зависимости между требованиями, найденные в md-файле спецификации (назависимо от их типов), кроме тех, что вписаны в колонку "Требование"
    - Если у требования несколько зависимых требований, раздели их запятыми
    - Если в спецификации нет зависимостей между требованиями, поставь прочерк (-)
    - Учитывай только явные ссылки в тексте требований (формат [ID-ТРЕБОВАНИЯ](#ссылка) или [ID-ТРЕБОВАНИЯ][#ссылка])
3. В колонку "Зависимости метода" впиши все методы, от которых зависит анализируемый метод, в следующем порядке:
    - Первый уровень: Методы, вызываемые напрямую из анализируемого метода
    - Второй уровень: Методы, вызываемые из методов первого уровня
    - Последующие уровни: Методы, вызываемые из методов предыдущих уровней
    - Формат представления цепочки зависимостей: метод_первого_уровня() → метод_второго_уровня() → метод_третьего_уровня()
    - Правила форматирования:
        - Разделяй разные цепочки зависимостей запятыми
        - Для методов из модуля метода, указанного в колонке "Метод" используй формат имя_метода(), если только у них нет прямого указания на иной модуль
        - Для методов из других модулей используй формат модуль.имя_метода()
        - Если метод вызывает несколько методов, перечисли их все в соответствующей цепочке
        - Если цепочка вызовов разветвляется, продолжай анализ по каждой ветке до конца, затем переходи к следующей ветке
        - Если метод не вызывает другие методы или цепочка завершена, отобрази только достигнутые уровни (или прочерк, если это основной анализируемый метод без вызовов)
        - Сохраняй порядок вызовов как в исходном коде
4. Алгоритм построения цепочки зависимостей:
    - Начни с основного анализируемого метода (указанного в docstring)
    - Найди все методы, которые он вызывает напрямую (первый уровень)
    - Для каждого метода первого уровня найди все методы, которые он вызывает (второй уровень)
    - Продолжай анализ рекурсивно для каждого найденного метода
    - Собери все уникальные методы в порядке обхода (сначала глубина, затем ширина)
    - Исключи повторяющиеся методы в цепочке (если метод вызывается несколько раз, укажи его только один раз)
5. Каждая уникальная комбинация спецификации и модуля/метода должна быть отдельной строкой

Дополнительные инструкции:
    - Если в docstring указано несколько требований, включи их все
    - Если в спецификации найдены зависимости между требованиями, включи все связанные требования
    - Сохраняй исходный порядок и форматирование идентификаторов требований
    - Если для одной спецификации есть несколько методов в разных модулях, создай отдельные строки для каждой пары модуль-метод
    - При анализе вызовов методов учитывай только явные вызовы функций и методов внутри тела функции
    - Игнорируй импорты, определения переменных и другие конструкции, не являющиеся вызовами методов
    - Если метод вызывает сам себя (рекурсия), укажи это как метод() [рекурсия]
    - Учитывай только методы, которые определены в предоставленных файлах

Анализ в ответе не отображай, выведи только таблицу в формате markdown в блоке кода.
```

|Спецификация|Требование|Зависимости требования|Модуль|Метод|Зависимости метода|
|---|---|---|---|---|---|
|SPEC-FEATURE-DELIVERY-NOTE-001|FR-DELIVERY-NOTE-CREATE-001|NFR-DELIVERY-NOTE-CREATE-001|delivery_note|gln_epass()|-|
|SPEC-FEATURE-DELIVERY-NOTE-001|FR-DELIVERY-NOTE-CREATE-002|FR-DELIVERY-NOTE-CREATE-001|delivery_note|shipper_gln()|gln_epass()|
|SPEC-FEATURE-DELIVERY-NOTE-001|FR-DELIVERY-NOTE-CREATE-003|NFR-DELIVERY-NOTE-CREATE-002|delivery_note|delivery_note_create()|shipper_gln() → gln_epass()|
|SPEC-FEATURE-DELIVERY-NOTE-DRAFTS|FR-DELIVERY-NOTE-DRAFTS-CREATE-001|FR-DELIVERY-NOTE-DRAFTS-CREATE-002, NFR-PQ-PE-TB-DRAFTS-001|delivery_note_draft|delivery_note_draft_create()|delivery_note.delivery_note_create() → delivery_note.shipper_gln() → delivery_note.gln_epass()|